import math
import graph

import random

#This will generate a random euclidian graph
#The graph is stored in a file that is created
#@Param
#   -> n - the number of nodes of the graph
#   -> window - the size of the plane for the x and y coordinates
#   -> fileName - the name of the file to be generated, should end with .txt
def genEuclidian(n, window, fileName):
    file = open(fileName,"w+")
    
    for i in range(0, n):
        x = random.randint(0, window)
        y = random.randint(0, window)

        node = "" + str(x) + " " + str(y) + "\n"
        
        file.write(node)

    file.close() 

#This will generate a random metric graph. The generation of the
#metric graph is based on transforming a non-metric graph into a metric graph.
#This is done by considering all triples of edges in the non-metric graph
#that violate the triangle inequality, which allows us to extract the value Q
#that each edge in the graph should be increased by to transform the graph
#into a metric one. This value is obtained by considering the weight amount
#required to lift the violation for all triplets,
#                       Q = w(i,j) - w(i,k) - w(k,j)
#and choosing the largest value. For more info,
#http://theory.stanford.edu/~trevisan/cs261/all-notes-2010.pdf
#
#The graph is stored in a file that is created
#@Param
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> maxRange - the maximum weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def genMetric(n, minRange, maxRange, fileName):
    file = open(fileName, "w+")

    data = [[0] * n for i in range(0,n)]
    
    for i in range(0, n):
        for j in range(i + 1, n):
            weight = random.randint(minRange, maxRange)
            data[i][j] = weight
            data[j][i] = weight
            
    change = []         #Holds the weight amount required to lift the violation
                        #for each triplet
    
    for i in range(0, n):
        for j in range(0, n):
            for k in range(0, n):
                change.append(data[i][j] - data[i][k] - data[k][j])

    maxChange = max(change)

    for i in range(0, n):
        for j in range(i + 1, n):
            weight = data[i][j]
            newWeight = weight + maxChange #Ensures triangle inequality
            node = "" + str(i) + " " + str(j) + " " + str(newWeight) + "\n"
            file.write(node)

    file.close()

#This function generates a random metric graph in a different way to that
#of the above genMetric function. The difference is that the generation
#will be based on the weights being in an interval [A, B) where 2*A > B.
#This is because this will ensure that the sum of any two edges in any triangle
#is always larger than the third edge.
#The graph is stored in a file that is created
#@Param
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def genMetric2(n, minRange, fileName):
    file = open(fileName, "w+")

    maxRange = 2 * minRange    #This will ensure that the range of the selected weights
                               #satisfy the metric case
    for i in range(0, n):
        for j in range(i + 1, n):
            weight = random.randint(minRange, maxRange)
            node = "" + str(i) + " " + str(j) + " " + str(weight) + "\n"
            file.write(node)

    file.close()
    

#This will generate a random non-metric graph
#   -> The probability of a metric graph being generated is extremely small
#   -> We are ensuring that if the weight range provided is [A, B) where 2A > B
#      then we want to readjust the weight such that the graph is not guaranteed to be metric
#The graph is stored in a file that is created
#@Param
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> maxRange - the maximum weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def nonMetric(n, minRange, maxRange, fileName):
    file = open(fileName, "w+")

    if (2 * minRange > maxRange): #If weights are in this region then graph guaranteed to be metric
        minRange = maxRange / random.randint(2, 10) #This ensures that the region can generate metric graphs
    
    for i in range(0, n):
        for j in range(i + 1, n):
            weight = random.randint(minRange, maxRange)
            node = "" + str(i) + " " + str(j) + " " + str(weight) + "\n"
            file.write(node)

    file.close()
                
#This function generates a euclidian graph based on the provided parameters
#and prints out the optimal tour generated by each of the TSP approximation
#algorithms written in the graph.py file.
#@Param
#   -> n - the number of nodes of the graph
#   -> window - the size of the plane for the x and y coordinates
#   -> fileName - the name of the file to be generated, should end with .txt
def test_euclidian(n, window, fileName):
    
    genEuclidian(n, window, fileName)
    g = graph.Graph(-1,fileName)
    test(g)

#This function generates a metric graph based on the provided parameters
#and prints out the optimal tour generated by each of the TSP approximation
#algorithms written in the graph.py file
#@Param
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> maxRange - the maximum weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def test_metric(n, minRange, maxRange, fileName):

    genMetric(n, minRange, maxRange, fileName)
    g = graph.Graph(n,fileName)
    test(g)

#This function generates a metric graph using the method specified in the
#genMetric2 function and then prints out the optimal tour generated by each of the TSP approximation
#algorithms written in the graph.py file
#@Param
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def test_metric2(n, minRange, fileName):

    genMetric2(n, minRange, fileName)
    g = graph.Graph(n,fileName)
    test(g)

#This function generates a nonmetric graph based on the provided parameters
#and prints out the optimal tour generated by each of the TSP approximation
#algorithms written in the graph.py file
#   -> n - the number of nodes of the graph
#   -> minRange - the smallest weight an edge could have
#   -> maxRange - the maximum weight an edge could have
#   -> fileName - the name of the file to be generated, should end with .txt
def test_nonmetric(n, minRange, maxRange, fileName):

    nonMetric(n, minRange, maxRange, fileName)
    g = graph.Graph(n,fileName)
    test(g)

#This function prints the optimal tour for each of the implemented
#solutions for the TSP problem in the graph.py file for the given graph object
#@Param
#   -> g - the graph object to examine
def test(g):
    
    for i in range(0, 4): #We have 4 solutions implemented
        g.perm = graph.initPerm(g.n) #Ensures each method starts with same permutation of cities
        
        if (i == 0):
            g.swapHeuristic(g.n) #The k value is provided as the number of nodes to be polynomially bounded
            print("Swap Heuristic: " + str(g.tourValue()))
        elif (i == 1):
            g.swapHeuristic(g.n)
            g.TwoOptHeuristic(g.n)
            print("2-opt Heuristic: " + str(g.tourValue()))
        elif (i == 2):
            g.Greedy()
            print("Greedy: " + str(g.tourValue()))
        elif(i == 3):
            g.FarthestInsertHeuristic()
            print("FarthestInsert: " + str(g.tourValue()))
